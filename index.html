<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Organizador de Dados de Concurso</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script> <!-- jsPDF -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.2/jspdf.plugin.autotable.min.js"></script> <!-- autoTable -->
    <style>
    body {
        font-family: Arial, sans-serif;
        margin: 0;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        align-items: center;
        min-height: 100vh;
        background-color: #e0f7fa;
    }
    .container {
        background-color: #f9f9f9;
        padding: 20px;
        border-radius: 10px;
        margin-top: 20px;
        width: 80%;
        max-width: 600px;
        text-align: center;
    }
    .container2 {
        background-color: #f9f9f9;
        padding: 20px;
        border-radius: 10px;
        margin-top: 20px;
        width: 70%;
        max-width: 90%;
	overflow-x:auto;
        text-align: center;
	align-items: center;
        display: none;
    }
    .form-group {
        margin-bottom: 15px;
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    .form-group label {
        display: block;
        margin-bottom: 5px;
        font-weight: bold;
        text-align: center;
        color: #4CAF50;
    }
    textarea, select, input, button {
        border-radius: 10px;
        border: 1px solid #4CAF50;
        padding: 10px;
        width: 70%;
        box-sizing: border-box;
        color: #004d40;
    }
    button {
        cursor: pointer;
        background-color: #4CAF50;
        color: white;
        border: none;
        margin-top: 10px;
        padding: 7px 10px;
        width: auto;
        display: inline-block;
        max-width: 180px;
    }
    button:hover {
        background-color: #388E3C;
    }
    table {
        width: 100%;
        border-collapse: collapse;
	align-items: center;
	text-align: center;
        margin-top: 20px;
	margin: auto;
	border-radius: 10px;
	overflow: hidden;
    }
    th, td {
        border: 1px solid #4CAF50;
        padding: 8px;
        text-align: center;
        cursor: pointer;
    }
    th {
        background-color: #4CAF50;
        color: white;
    }
    td {
        background-color: #f2f2f2;
    }
    tr:nth-child(even) td {
        background-color: #e0f2f1;
    }
    #columnNames input {
        margin-bottom: 5px;
    }
    .checkbox-group {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin-bottom: 15px;
    }
    .searchContainer {
        margin-top: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    .footer {
        margin-top: auto;
	margin-bottom: auto;
        text-align: center;
        padding: 20px;
        background-color: transparent;
        width: 80%;
        max-width: 600px;
        border-top: 1px solid #ddd;
        box-sizing: border-box;
    }
    .footer img {
        width: 100px;
        border-radius: 50%;
        margin-bottom: 10px;
    }
    .footer p {
        margin: 0;
        font-size: 14px;
        color: #555;
    }
    @media (max-width: 768px) {
        .container, .container2 {
            width: 90%;
        }
        textarea, select, input, button {
            width: 90%;
        }
        .footer {
            width: 90%;
        }
    }
    @media (max-width: 480px) {
        .container, .container2 {
            width: 100%;
            padding: 10px;
        }
        textarea, select, input, button {
            width: 100%;
        }
        button {
            padding: 8px 16px;
        }
        .footer {
            width: 100%;
            padding: 10px;
        }
    }
    </style>
</head>

<body>
    <div class="container">
        <h1>Organizador de Dados de Concurso</h1>
        <form id="organizeForm">
            <div class="form-group">
                <label for="dataInput" title="Insira a lista dos candidatos, separados por '/'.">Lista dos candidatos (do Diário Oficial ou da Banca):</label>
                <textarea id="dataInput" name="dataInput" rows="4" cols="50" title="Insira a lista dos candidatos, separados por barra (/)."></textarea>
            </div>
            <label>
                <input type="checkbox" id="addRankingColumn" name="addRankingColumn" title="Selecione para adicionar uma coluna de classificação.">
                <br>Adicionar coluna de classificação
            </label>
			<br>
            <button type="button" onclick="organizeData()" title="Clique para organizar os dados.">Organizar</button>
        </form>
    </div>

    <div class="container2" id="ContainerResult">
        <h1>Resultado Organizado</h1>
        <div class="searchContainer">
            <input type="text" id="searchInput" onkeyup="searchTable()" placeholder="Digite para pesquisar..." title="A tabela vai atualizando ao digitar...">
        </div>
        <button type="button" onclick="generatePDF()" title="Clique para gerar um PDF com os dados da tabela.">Gerar PDF</button>
        <h4><i>Ao clicar no cabeçalho da tabela, os dados são organizados conforme a coluna clicada!</i></h4>
        <table border="1" id="resultTable">
            <thead>
                <tr id="tableHeaders"></tr>
            </thead>
            <tbody id="tableBody"></tbody>
        </table>
    </div>

    <footer class="footer">
        <img src="minha_foto.jpg" alt="Foto do Autor">
        <p><b>Autor: Júnior Chaves</b></p>
    </footer>

    <script>
    // Variável global para armazenar a direção de ordenação de cada coluna
let sortDirections = [];

function organizeData() {
    document.getElementById('ContainerResult').style.display = 'block';

    const dataInput = document.getElementById('dataInput').value.trim();
    const addRankingColumn = document.getElementById('addRankingColumn').checked;
    let columnNames = [];

    function parseCandidate(candidateStr) {
        const separator = candidateStr.includes(';') ? ';' : ',';
        const parts = candidateStr.trim().split(separator).map(part => part.trim());

        if (!candidateStr || parts.length < 3) {
            return null;
        }

        let classificacao = null;
        let inscricao = null;
        let nome = null;
        let notasRaw = [];
        let pontuacaoTotal = 0;
        let posicao = null;

        // Tentar identificar o padrão: Classificação, Inscrição, Nome, Nota
        // Ex: "1, 16545, ALEF FREITAS DA SILVA, 56.00"
        // Verificar se os dois primeiros campos são numéricos e o terceiro não é (provavelmente o nome)
        // e se o último campo é um número.
        if (parts.length >= 4 && !isNaN(parseFloat(parts[0])) && !isNaN(parseFloat(parts[1])) && isNaN(parseFloat(parts[2].replace(',', '.'))) && !isNaN(parseFloat(parts[parts.length - 1].replace(',', '.')))) {
            // Se o primeiro campo tem "º", é posição, não classificação numérica simples
            if (!parts[0].includes('º')) {
                classificacao = parseInt(parts.shift());
                inscricao = parts.shift();
                nome = parts.shift();
                // O restante das partes (se houver mais de 1) pode ser parte do nome, então pegamos a última como nota
                const lastPart = parts.pop();
                if (!isNaN(parseFloat(lastPart.replace(',', '.')))) {
                    const nota = parseFloat(lastPart.replace(',', '.'));
                    return [inscricao, nome, nota, classificacao]; // Retorna no formato [inscricao, nome, nota, classificacao]
                }
            }
        }


        // Lógica existente para outros formatos (mantida e ajustada para funcionar após a nova detecção)
        const isFirstFieldNumeric = !isNaN(parseFloat(parts[0].replace('º', '')));

        if (isFirstFieldNumeric && parts[0].includes('º')) {
            posicao = parseInt(parts.shift().replace('º', ''));
            inscricao = parts.shift();
            nome = parts.shift();
            notasRaw = parts;
        } else if (isFirstFieldNumeric && parts.length >= 3) { // Alterado para garantir que há pelo menos nome, inscrição e algo mais
            inscricao = parts.shift();
            nome = parts.shift();
            notasRaw = parts;
        } else {
            nome = parts.shift();
            inscricao = parts.shift();
            notasRaw = parts;
        }

        const processedNotas = [];
        for (let i = 0; i < notasRaw.length; i++) {
            if (notasRaw[i].includes('º')) {
                posicao = parseInt(notasRaw[i].replace('º', ''));
            } else if (!isNaN(parseFloat(notasRaw[i].replace(',', '.')))) {
                // Verificar se é uma nota decimal no formato "103,8" seguida por posição
                if (i + 2 < notasRaw.length && !isNaN(parseFloat(notasRaw[i + 1])) && notasRaw[i + 2].includes('º') && !notasRaw[i + 1].includes('.')) {
                    const decimalValue = parseFloat(`${notasRaw[i]}.${notasRaw[i + 1]}`);
                    processedNotas.push(decimalValue);
                    pontuacaoTotal += decimalValue;
                    i++; // Pular a parte decimal
                } else {
                    const value = parseFloat(notasRaw[i].replace(',', '.'));
                    processedNotas.push(value);
                    pontuacaoTotal += value;
                }
            } else {
                processedNotas.push(notasRaw[i]);
            }
        }

        // Determinar o formato final da saída da função parseCandidate
        if (processedNotas.length === 1 && posicao === null) {
            return [inscricao, nome, processedNotas[0]]; // Ex: [inscricao, nome, nota]
        } else if (processedNotas.length === 1 && posicao !== null) {
            return [inscricao, nome, processedNotas[0], posicao]; // Ex: [inscricao, nome, nota, posicao]
        } else if (processedNotas.length > 1) {
            return [inscricao, nome, ...processedNotas, pontuacaoTotal]; // Ex: [inscricao, nome, nota1, nota2, ..., pontuacaoTotal]
        } else {
            // Caso não se encaixe nos padrões acima, ou faltem notas
            return [inscricao, nome, null]; // Retorna com nota nula para evitar erro
        }
    }

    const candidates = dataInput.split('/')
        .map(candidate => candidate.trim())
        .filter(candidate => candidate.length > 0)
        .map(parseCandidate)
        .filter(candidate => candidate !== null);

    if (candidates.length > 0) {
        // Agora precisamos ajustar a lógica para `columnNames` e `sortedCandidates`
        // para considerar o novo formato de entrada (Classificação, Inscrição, Nome, Nota)

        // Se o último elemento é a classificação (inteiro) e a lista tem 4 itens: [inscricao, nome, nota, classificacao]
        const isNewClassificationFormat = candidates[0].length === 4 && Number.isInteger(candidates[0][candidates[0].length - 1]);
        const numNotas = candidates[0].length - 2 - (isNewClassificationFormat ? 1 : 0); // Ajusta numNotas se for o novo formato
        const hasPosicao = !isNewClassificationFormat && candidates[0].length === 4 && Number.isInteger(candidates[0][candidates[0].length - 1]);
        const hasPontuacaoTotal = !isNewClassificationFormat && candidates[0].length > 3 && !hasPosicao;

        columnNames = ['Inscrição', 'Nome'];

        if (numNotas > 0 || isNewClassificationFormat) { // Se for o novo formato, sempre terá uma "Nota"
            columnNames.push(`Nota`); // Ou "Nota 1" se houver múltiplos
        }

        if (isNewClassificationFormat) {
            columnNames.push('Classificação'); // Adiciona Classificação ao final se for o novo formato
        } else if (hasPosicao) {
            columnNames.push('Posição');
        } else if (numNotas > 1) {
            columnNames.push('Pontuação Total');
        }
    }

    const sortedCandidates = candidates.sort((a, b) => {
        // Lógica de ordenação adaptada para o novo formato
        const isNewClassificationFormat = a.length === 4 && Number.isInteger(a[a.length - 1]);

        if (isNewClassificationFormat) {
            // No novo formato [inscricao, nome, nota, classificacao], ordenar pela nota (índice 2)
            // Ordem decrescente por padrão para notas
            return parseFloat(b[2]) - parseFloat(a[2]);
        }
        // Lógica existente para outros formatos (pontuação total ou nota única)
        else if (a.length <= 4) { // Única nota (com ou sem posição)
             return parseFloat(b[2]) - parseFloat(a[2]);
        } else { // Múltiplas notas
            return parseFloat(b[b.length - 1]) - parseFloat(a[b.length - 1]);
        }
    });

    let organizedData = sortedCandidates.map(candidate => {
        // Se for o novo formato, reordena para [inscricao, nome, nota, classificacao] para a exibição
        // Mas a coluna 'Classificação' já é adicionada no `columnNames` separadamente
        // Se a checkbox 'addRankingColumn' estiver marcada, a classificação gerada sobrescreve.
        // Se não, e o formato de entrada já tiver a classificação, ela será exibida no lugar certo.
        if (candidate.length === 4 && Number.isInteger(candidate[candidate.length - 1])) {
            const [insc, nome, nota, classif] = candidate;
            // Retorna os dados como espera a `updateTable` para o novo formato
            // se a 'Classificação' não for gerada pelo 'addRankingColumn'
            return [insc, nome, nota, classif];
        }
        return candidate;
    });

    // Se 'addRankingColumn' está marcado, adiciona a classificação como primeira coluna
    if (addRankingColumn) {
        // Verifica se a coluna "Classificação" já existe nos columnNames.
        // Se já existe do formato de entrada, e a gente está adicionando um ranking,
        // é uma substituição ou um ranking adicional?
        // Neste contexto, vamos *sempre* adicionar uma coluna de Classificação gerada
        // se a checkbox estiver marcada, e ela será a primeira.
        // O `isNewClassificationFormat` lida com a classificação original do dado de entrada.
        
        // Remove 'Classificação' se já foi adicionada pelo isNewClassificationFormat
        // para evitar duplicidade antes de adicionar a gerada
        const classifIndexInColNames = columnNames.indexOf('Classificação');
        if (classifIndexInColNames !== -1) {
            columnNames.splice(classifIndexInColNames, 1);
            // Também remove do organizedData se já existia
            organizedData = organizedData.map(row => {
                if (row.length === columnNames.length + 1) { // +1 porque a classificação foi removida de columnNames
                    const [insc, nome, nota, classif] = row; // Assume o formato [insc, nome, nota, classif]
                    return [insc, nome, nota]; // Remove a classificação original
                }
                return row;
            });
        }

        // Adiciona a coluna de Classificação gerada dinamicamente
        organizedData = organizedData.map((candidate, index) => [index + 1, ...candidate]);
        columnNames.unshift('Classificação');
    }

    updateTable(columnNames, organizedData);
}

function updateTable(columnNames, data) {
    const tableHeaders = document.getElementById('tableHeaders');
    const tableBody = document.getElementById('tableBody');
    tableHeaders.innerHTML = '';
    tableBody.innerHTML = '';

    // Criar cabeçalhos
    columnNames.forEach(columnName => {
        const th = document.createElement('th');
        th.textContent = columnName;
        th.onclick = () => sortTable(columnNames.indexOf(columnName));
        tableHeaders.appendChild(th);
    });

    // Criar linhas da tabela
    data.forEach(row => {
        const tr = document.createElement('tr');
        for (let i = 0; i < columnNames.length; i++) {
            const td = document.createElement('td');
            // Formata números com duas casas decimais se for nota/pontuação
            // Ou se for a coluna de Classificação gerada pelo addRankingColumn
            const isNumericColumn = columnNames[i].includes('Nota') || columnNames[i].includes('Pontuação Total');
            const isGeneratedRankingColumn = columnNames[i] === 'Classificação' && columnNames.indexOf('Classificação') === 0; // Se for a primeira coluna e for 'Classificação'

            if (isNumericColumn && row[i] !== null && row[i] !== undefined && !isNaN(parseFloat(row[i]))) {
                 td.textContent = parseFloat(row[i]).toFixed(2);
            } else {
                 td.textContent = row[i] !== null && row[i] !== undefined ? row[i] : '';
            }
            tr.appendChild(td);
        }
        tableBody.appendChild(tr);
    });

    // Corrige a ordenação inicial para "Nota" ou a primeira coluna numérica disponível
    const notaIndex = columnNames.findIndex(col => col.includes('Nota'));
    const classificacaoIndex = columnNames.findIndex(col => col.includes('Classificação'));

    // Inicializa sortDirections para as colunas relevantes
    columnNames.forEach((col, index) => {
        if (col.includes('Nota') || col.includes('Pontuação Total') || col === 'Classificação') {
            sortDirections[index] = false; // Decrescente por padrão
        } else {
            sortDirections[index] = true; // Crescente por padrão
        }
    });

    if (notaIndex !== -1) {
        sortTable(notaIndex); // Ordena inicialmente pela primeira coluna "Nota"
    } else if (classificacaoIndex !== -1) {
        sortTable(classificacaoIndex); // Se não tiver nota, ordena por Classificação
    }
}

// Sua função sortTable, agora integrada e adaptada
function sortTable(columnIndex) {
    const table = document.getElementById('resultTable');
    const tbody = table.getElementsByTagName('tbody')[0];
    const rows = Array.from(tbody.getElementsByTagName('tr'));

    // Certifique-se de que sortDirections está inicializado para a coluna clicada
    if (sortDirections[columnIndex] === undefined) {
        const headerText = table.querySelector(`th:nth-child(${columnIndex + 1})`).textContent;
        // Inicia decrescente para Notas, Pontuação Total e Classificação
        sortDirections[columnIndex] = !(headerText.includes('Nota') || headerText.includes('Pontuação Total') || headerText === 'Classificação');
    }

    const sortedRows = rows.sort((a, b) => {
        const textA = a.cells[columnIndex].textContent.trim();
        const textB = b.cells[columnIndex].textContent.trim();

        const numA = parseFloat(textA.replace(',', '.'));
        const numB = parseFloat(textB.replace(',', '.'));

        if (!isNaN(numA) && !isNaN(numB)) {
            return sortDirections[columnIndex] ? numA - numB : numB - numA;
        } else {
            return sortDirections[columnIndex] ? textA.localeCompare(textB) : textB.localeCompare(textA);
        }
    });

    // Inverte a direção para o próximo clique
    sortDirections[columnIndex] = !sortDirections[columnIndex];

    tbody.innerHTML = '';
    sortedRows.forEach(row => tbody.appendChild(row));
}

// O window.onload agora só precisa garantir que o sortDirections esteja pronto quando a página carregar
window.onload = function() {
    // Isso é importante para o primeiro clique em um cabeçalho
    // A inicialização específica para cada coluna ocorre dentro de updateTable,
    // garantindo que sortDirections tenha os valores corretos baseados nos headers atuais.
};

    function searchTable() {
        let input = document.getElementById('searchInput').value.toUpperCase();
        let table = document.getElementById('resultTable');
        let tr = table.getElementsByTagName('tr');

        for (let i = 1; i < tr.length; i++) {
            let td = tr[i].getElementsByTagName('td');
            let found = false;
            for (let j = 0; j < td.length; j++) {
                if (td[j] && td[j].innerHTML.toUpperCase().indexOf(input) > -1) {
                    found = true;
                    break;
                }
            }
            tr[i].style.display = found ? '' : 'none';
        }
    }

    function generatePDF() {
    try {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();

        const margin = 10;
        let y = margin;
        const lineHeight = 10;
        const pageWidth = doc.internal.pageSize.getWidth();

        // Título centralizado e em negrito
        doc.setFontSize(16);
        doc.setFont("helvetica", "bold");
        const title = "Relatório de Resultados";
        const titleWidth = doc.getTextWidth(title);
        const x = (pageWidth - titleWidth) / 2;
        doc.text(title, x, y);
        y += lineHeight * 2;

        const table = document.getElementById('resultTable');
        if (!table || table.querySelector('tbody').children.length === 0) {
            alert("Erro: Gere a tabela primeiro clicando em 'Organizar'!");
            return;
        }

        const headers = Array.from(table.querySelectorAll('thead th')).map(th => th.textContent);
        const rows = Array.from(table.querySelectorAll('tbody tr')).map(tr =>
            Array.from(tr.querySelectorAll('td')).map(td => 
                td.textContent.replace(/\s*\n\s*/g, ' ').trim() // Remove quebras de linha e junta com espaço
            )
        );

        doc.autoTable({
            head: [headers],
            body: rows,
            startY: y,
            margin: { left: margin, right: margin },
            styles: { fontSize: 10, cellPadding: 2 },
            headStyles: { fillColor: [76, 175, 80], textColor: 255 },
            alternateRowStyles: { fillColor: [224, 242, 241] },
        });

        const pdfBlob = doc.output('blob');
        const pdfUrl = URL.createObjectURL(pdfBlob);
        window.open(pdfUrl, '_blank');
    } catch (error) {
        console.error("Erro ao gerar PDF:", error);
        alert("Erro ao gerar PDF. Veja o console para detalhes.");
    }
    }
    </script>
</body>
</html>
