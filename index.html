<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Organizador de Dados de Concurso</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script> <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.2/jspdf.plugin.autotable.min.js"></script> <style>
    body {
        font-family: Arial, sans-serif;
        margin: 0;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        align-items: center;
        min-height: 100vh;
        background-color: #e0f7fa;
    }
    .container {
        background-color: #f9f9f9;
        padding: 20px;
        border-radius: 10px;
        margin-top: 20px;
        width: 80%;
        max-width: 600px;
        text-align: center;
    }
    .container2 {
        background-color: #f9f9f9;
        padding: 20px;
        border-radius: 10px;
        margin-top: 20px;
        width: 70%;
        max-width: 90%;
        overflow-x:auto;
        text-align: center;
        align-items: center;
        display: none; /* Inicia oculto */
    }
    .form-group {
        margin-bottom: 15px;
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    .form-group label {
        display: block;
        margin-bottom: 5px;
        font-weight: bold;
        text-align: center;
        color: #4CAF50;
    }
    textarea, select, input, button {
        border-radius: 10px;
        border: 1px solid #4CAF50;
        padding: 10px;
        width: 70%;
        box-sizing: border-box;
        color: #004d40;
    }
    button {
        cursor: pointer;
        background-color: #4CAF50;
        color: white;
        border: none;
        margin-top: 10px;
        padding: 7px 10px;
        width: auto;
        display: inline-block;
        max-width: 180px;
    }
    button:hover {
        background-color: #388E3C;
    }
    table {
        width: 100%;
        border-collapse: collapse;
        align-items: center;
        text-align: center;
        margin-top: 20px;
        margin: auto;
        border-radius: 10px;
        overflow: hidden;
    }
    th, td {
        border: 1px solid #4CAF50;
        padding: 8px;
        text-align: center;
        cursor: pointer;
    }
    th {
        background-color: #4CAF50;
        color: white;
    }
    td {
        background-color: #f2f2f2;
    }
    tr:nth-child(even) td {
        background-color: #e0f2f1;
    }
    #columnNames input {
        margin-bottom: 5px;
    }
    .checkbox-group {
        display: flex;
        flex-direction: column;
        align-items: center;
        margin-bottom: 15px;
    }
    .searchContainer {
        margin-top: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    .footer {
        margin-top: auto;
        margin-bottom: auto;
        text-align: center;
        padding: 20px;
        background-color: transparent;
        width: 80%;
        max-width: 600px;
        border-top: 1px solid #ddd;
        box-sizing: border-box;
    }
    .footer img {
        width: 100px;
        border-radius: 50%;
        margin-bottom: 10px;
    }
    .footer p {
        margin: 0;
        font-size: 14px;
        color: #555;
    }
    @media (max-width: 768px) {
        .container, .container2 {
            width: 90%;
        }
        textarea, select, input, button {
            width: 90%;
        }
        .footer {
            width: 90%;
        }
    }
    @media (max-width: 480px) {
        .container, .container2 {
            width: 100%;
            padding: 10px;
        }
        textarea, select, input, button {
            width: 100%;
        }
        button {
            padding: 8px 16px;
        }
        .footer {
            width: 100%;
            padding: 10px;
        }
    }
    </style>
</head>

<body>
    <div class="container">
        <h1>Organizador de Dados de Concurso</h1>
        <form id="organizeForm">
            <div class="form-group">
                <label for="dataInput" title="Insira a lista dos candidatos, separados por '/'.">Lista dos candidatos (do Diário Oficial ou da Banca):</label>
                <textarea id="dataInput" name="dataInput" rows="4" cols="50" title="Insira a lista dos candidatos, separados por barra (/)."></textarea>
            </div>
            <label>
                <input type="checkbox" id="addRankingColumn" name="addRankingColumn" title="Selecione para adicionar uma coluna de classificação.">
                <br>Adicionar coluna de classificação
            </label>
            <br>
            <button type="button" onclick="organizeData()" title="Clique para organizar os dados.">Organizar</button>
        </form>
    </div>

    <div class="container2" id="ContainerResult">
        <h1>Resultado Organizado</h1>
        <div class="searchContainer">
            <input type="text" id="searchInput" onkeyup="searchTable()" placeholder="Digite para pesquisar..." title="A tabela vai atualizando ao digitar...">
        </div>
        <button type="button" onclick="generatePDF()" title="Clique para gerar um PDF com os dados da tabela.">Gerar PDF</button>
        <h4><i>Ao clicar no cabeçalho da tabela, os dados são organizados conforme a coluna clicada!</i></h4>
        <table border="1" id="resultTable">
            <thead>
                <tr id="tableHeaders"></tr>
            </thead>
            <tbody id="tableBody"></tbody>
        </table>
    </div>

    <footer class="footer">
        <img src="minha_foto.jpg" alt="Foto do Autor">
        <p><b>Autor: Júnior Chaves</b></p>
    </footer>

    <script>
        // Variável global para armazenar a direção de ordenação de cada coluna
        let sortDirections = [];

        function organizeData() {
            document.getElementById('ContainerResult').style.display = 'block';

            const dataInput = document.getElementById('dataInput').value.trim();
            const addRankingColumn = document.getElementById('addRankingColumn').checked;
            let columnNames = [];

            function parseCandidate(candidateStr) {
                const separator = candidateStr.includes(';') ? ';' : ',';
                const parts = candidateStr.trim().split(separator).map(part => part.trim());

                if (!candidateStr || parts.length < 2) {
                    return null; // Dados insuficientes
                }

                let classificacao = null;
                let inscricao = null;
                let nome = null;
                let notasRaw = [];
                let pontuacaoTotal = 0;
                let posicao = null;

                // --- TENTATIVA DE IDENTIFICAR FORMATO: Nome, Inscrição, Nota, Classificação (4 partes exatas) ---
                if (parts.length === 4 &&
                    isNaN(parseFloat(parts[0].replace(',', '.'))) && // Nome (não numérico)
                    Number.isInteger(parseFloat(parts[1])) && // Inscrição (DEVE ser inteiro)
                    !isNaN(parseFloat(parts[2].replace(',', '.'))) && // Nota (pode ser decimal)
                    Number.isInteger(parseFloat(parts[3])) // Classificação (DEVE ser inteiro)
                ) {
                    nome = parts[0];
                    inscricao = parts[1];
                    const nota = parseFloat(parts[2].replace(',', '.'));
                    classificacao = parseInt(parts[3]);
                    return { type: 'NomeInscNotaClassificacao', data: [inscricao, nome, nota, classificacao] };
                }

                // --- TENTATIVA DE IDENTIFICAR NOVO FORMATO: Inscrição, Nome, Nota, Classificação (4 partes exatas) ---
                if (parts.length === 4 &&
                    Number.isInteger(parseFloat(parts[0])) && // Inscrição (DEVE ser inteiro)
                    isNaN(parseFloat(parts[1].replace(',', '.'))) && // Nome (NÃO numérico)
                    !isNaN(parseFloat(parts[2].replace(',', '.'))) && // Nota (pode ser decimal)
                    Number.isInteger(parseFloat(parts[3])) // Classificação (DEVE ser inteiro)
                ) {
                    inscricao = parts[0];
                    nome = parts[1];
                    const nota = parseFloat(parts[2].replace(',', '.'));
                    classificacao = parseInt(parts[3]);
                    return { type: 'InscNomeNotaClassificacao', data: [inscricao, nome, nota, classificacao] };
                }

                // --- TENTATIVA DE IDENTIFICAR FORMATO: Classificação, Inscrição, Nome, Nota (mínimo 4 partes) ---
                if (parts.length >= 4 &&
                    Number.isInteger(parseFloat(parts[0])) && !parts[0].includes('º') && // Classificação (DEVE ser inteiro, sem 'º')
                    Number.isInteger(parseFloat(parts[1])) && // Inscrição (DEVE ser inteiro)
                    isNaN(parseFloat(parts[2].replace(',', '.'))) && // Nome (não numérico)
                    !isNaN(parseFloat(parts[parts.length - 1].replace(',', '.')))) // Último campo é a nota (pode ser decimal)
                {
                    classificacao = parseInt(parts.shift());
                    inscricao = parts.shift();
                    const lastPartAsNote = parseFloat(parts.pop().replace(',', '.'));
                    nome = parts.join(' ');
                    return { type: 'ClassificacaoInscNomeNota', data: [inscricao, nome, lastPartAsNote, classificacao] };
                }

                // --- TENTATIVA DE IDENTIFICAR O FORMATO: Nome, Nota1, Nota2, Nota3... (Primeiro não numérico, resto só notas) ---
                // Esta condição vem AGORA, depois das mais específicas de 4 partes com Inscrição/Classificação INTEIRA.
                if (isNaN(parseFloat(parts[0].replace(',', '.'))) && // Nome (não numérico)
                    parts.slice(1).every(p => !isNaN(parseFloat(p.replace(',', '.'))))) { // Todas as outras são numéricas (notas)
                    nome = parts[0];
                    const notas = parts.slice(1).map(p => parseFloat(p.replace(',', '.')));
                    pontuacaoTotal = notas.reduce((sum, current) => sum + current, 0);
                    return { type: 'NomeMultipleNotes', data: [null, nome, ...notas, pontuacaoTotal] }; // null para inscrição ausente
                }

                // --- LÓGICA EXISTENTE PARA OUTROS FORMATOS: (Posição/Inscrição, Nome, Notas...) ---
                let remainingParts = [...parts];

                const isFirstFieldNumeric = !isNaN(parseFloat(remainingParts[0].replace('º', '')));

                if (isFirstFieldNumeric && remainingParts[0].includes('º')) {
                    posicao = parseInt(remainingParts.shift().replace('º', ''));
                    inscricao = remainingParts.shift();
                    nome = remainingParts.shift();
                    notasRaw = remainingParts;
                } else if (isFirstFieldNumeric && remainingParts.length >= 3) {
                    inscricao = remainingParts.shift();
                    nome = remainingParts.shift();
                    notasRaw = remainingParts;
                } else {
                    nome = remainingParts.shift();
                    inscricao = remainingParts.shift();
                    notasRaw = remainingParts;
                }

                const processedNotas = [];
                for (let i = 0; i < notasRaw.length; i++) {
                    if (notasRaw[i].includes('º')) {
                        posicao = parseInt(notasRaw[i].replace('º', ''));
                    } else if (!isNaN(parseFloat(notasRaw[i].replace(',', '.')))) {
                        if (i + 2 < notasRaw.length && !isNaN(parseFloat(notasRaw[i + 1])) && notasRaw[i + 2].includes('º') && !notasRaw[i + 1].includes('.')) {
                            const decimalValue = parseFloat(`${notasRaw[i]}.${notasRaw[i + 1]}`);
                            processedNotas.push(decimalValue);
                            pontuacaoTotal += decimalValue;
                            i++;
                        } else {
                            const value = parseFloat(notasRaw[i].replace(',', '.'));
                            processedNotas.push(value);
                            pontuacaoTotal += value;
                        }
                    } else {
                        processedNotas.push(notasRaw[i]);
                    }
                }

                if (processedNotas.length === 1 && posicao === null) {
                    return { type: 'InscNomeSingleNote', data: [inscricao, nome, processedNotas[0]] };
                } else if (processedNotas.length === 1 && posicao !== null) {
                    return { type: 'InscNomeNotaPosicaoXgrau', data: [inscricao, nome, processedNotas[0], posicao] };
                } else if (processedNotas.length > 1) {
                    return { type: 'InscNomeMultipleNotes', data: [inscricao, nome, ...processedNotas, pontuacaoTotal] };
                } else {
                    return { type: 'Unknown', data: [inscricao, nome, null] };
                }
            }

            const candidates = dataInput.split('/')
                .map(candidate => candidate.trim())
                .filter(candidate => candidate.length > 0)
                .map(parseCandidate)
                .filter(candidate => candidate !== null);

            if (candidates.length === 0) {
                updateTable([], []);
                return;
            }

            const firstCandidateType = candidates[0].type;
            const firstCandidateData = candidates[0].data;

            columnNames = [];

            if (firstCandidateType === 'NomeInscNotaClassificacao') {
                columnNames = ['Nome', 'Inscrição', 'Nota', 'Classificação'];
            } else if (firstCandidateType === 'InscNomeNotaClassificacao') {
                columnNames = ['Inscrição', 'Nome', 'Nota', 'Classificação'];
            } else if (firstCandidateType === 'ClassificacaoInscNomeNota') {
                columnNames = ['Classificação', 'Inscrição', 'Nome', 'Nota'];
            } else if (firstCandidateType === 'NomeMultipleNotes') {
                columnNames = ['Nome'];
                const numActualNotes = firstCandidateData.length - 3; // Total - null - nome - pontuacaoTotal
                for (let i = 1; i <= numActualNotes; i++) {
                    columnNames.push(`Nota ${i}`);
                }
                columnNames.push('Pontuação Total');
            } else if (firstCandidateType === 'InscNomeMultipleNotes') {
                columnNames = ['Inscrição', 'Nome'];
                for (let i = 1; i <= firstCandidateData.length - 3; i++) {
                    columnNames.push(`Nota ${i}`);
                }
                columnNames.push('Pontuação Total');
            } else if (firstCandidateType === 'InscNomeNotaPosicaoXgrau') {
                columnNames = ['Inscrição', 'Nome', 'Nota', 'Posição'];
            } else if (firstCandidateType === 'InscNomeSingleNote') {
                columnNames = ['Inscrição', 'Nome', 'Nota'];
            } else {
                columnNames = ['Campo 1', 'Campo 2', 'Campo 3'];
                for(let i = 3; i < firstCandidateData.length; i++) {
                    columnNames.push(`Campo ${i + 1}`);
                }
            }

            const sortedCandidates = candidates.sort((a, b) => {
                let valA, valB;

                if (a.type === 'NomeMultipleNotes' || a.type === 'InscNomeMultipleNotes') {
                    valA = parseFloat(a.data[a.data.length - 1]);
                    valB = parseFloat(b.data[b.data.length - 1]);
                } else if (a.type === 'NomeInscNotaClassificacao' || a.type === 'InscNomeNotaClassificacao' ||
                           a.type === 'ClassificacaoInscNomeNota' || a.type === 'InscNomeNotaPosicaoXgrau' ||
                           a.type === 'InscNomeSingleNote') {
                    valA = parseFloat(a.data[2]);
                    valB = parseFloat(b.data[2]);
                } else {
                    valA = parseFloat(a.data[0]);
                    valB = parseFloat(b.data[0]);
                }

                return valB - valA;
            });

            let organizedData = sortedCandidates.map(candidate => {
                const data = candidate.data;
                if (candidate.type === 'NomeInscNotaClassificacao') {
                    const [insc, nome, nota, classif] = data;
                    return [nome, insc, nota, classif];
                } else if (candidate.type === 'InscNomeNotaClassificacao') {
                    return [...data];
                } else if (candidate.type === 'ClassificacaoInscNomeNota') {
                    const [insc, nome, nota, classif] = data;
                    return [classif, insc, nome, nota];
                } else if (candidate.type === 'NomeMultipleNotes') {
                    const [, nome, ...rest] = data; // Remove o 'null' da inscrição
                    return [nome, ...rest]; // rest contém [nota1, nota2, nota3, pontuacaoTotal]
                } else {
                    return [...data];
                }
            });

            if (addRankingColumn) {
                const existingClassifOrPosicaoIndex = columnNames.findIndex(col => col === 'Classificação' || col === 'Posição');
                if (existingClassifOrPosicaoIndex !== -1) {
                    columnNames.splice(existingClassifOrPosicaoIndex, 1);
                    organizedData = organizedData.map(row => {
                        const newRow = [...row];
                        newRow.splice(existingClassifOrPosicaoIndex, 1);
                        return newRow;
                    });
                }
                organizedData = organizedData.map((candidateRow, index) => [index + 1, ...candidateRow]);
                columnNames.unshift('Classificação');
            }

            updateTable(columnNames, organizedData);
        }

        function updateTable(columnNames, data) {
            const tableHeaders = document.getElementById('tableHeaders');
            const tableBody = document.getElementById('tableBody');
            tableHeaders.innerHTML = '';
            tableBody.innerHTML = '';

            columnNames.forEach(columnName => {
                const th = document.createElement('th');
                th.textContent = columnName;
                th.onclick = () => sortTable(columnNames.indexOf(columnName));
                tableHeaders.appendChild(th);
            });

            data.forEach(row => {
                const tr = document.createElement('tr');
                for (let i = 0; i < columnNames.length; i++) {
                    const td = document.createElement('td');
                    const isNumericColumn = columnNames[i].includes('Nota') || columnNames[i].includes('Pontuação Total');
                    const isGeneratedRankingColumn = (columnNames[i] === 'Classificação' && i === 0 && document.getElementById('addRankingColumn').checked);

                    if ((isNumericColumn || isGeneratedRankingColumn || columnNames[i] === 'Classificação' || columnNames[i] === 'Posição') && row[i] !== null && row[i] !== undefined && !isNaN(parseFloat(row[i]))) {
                         td.textContent = parseFloat(row[i]).toFixed(2);
                         if (isGeneratedRankingColumn || columnNames[i] === 'Classificação' || columnNames[i] === 'Posição') {
                             td.textContent = parseInt(row[i]).toString();
                         }
                    } else {
                         td.textContent = row[i] !== null && row[i] !== undefined ? row[i] : '';
                    }
                    tr.appendChild(td);
                }
                tableBody.appendChild(tr);
            });

            columnNames.forEach((col, index) => {
                if (col.includes('Nota') || col.includes('Pontuação Total') || col === 'Classificação' || col === 'Posição') {
                    sortDirections[index] = false;
                } else {
                    sortDirections[index] = true;
                }
            });

            const pontuacaoTotalIndex = columnNames.findIndex(col => col.includes('Pontuação Total'));
            const notaIndex = columnNames.findIndex(col => col.includes('Nota'));
            const classificacaoIndex = columnNames.findIndex(col => col.includes('Classificação'));
            const posicaoIndex = columnNames.findIndex(col => col.includes('Posição'));


            if (pontuacaoTotalIndex !== -1) {
                sortTable(pontuacaoTotalIndex);
            } else if (notaIndex !== -1) {
                sortTable(notaIndex);
            } else if (classificacaoIndex !== -1) {
                sortTable(classificacaoIndex);
            } else if (posicaoIndex !== -1) {
                sortTable(posicaoIndex);
            }
        }

        function sortTable(columnIndex) {
            const table = document.getElementById('resultTable');
            const tbody = table.getElementsByTagName('tbody')[0];
            const rows = Array.from(tbody.getElementsByTagName('tr'));

            if (sortDirections[columnIndex] === undefined) {
                const headerText = table.querySelector(`th:nth-child(${columnIndex + 1})`).textContent;
                sortDirections[columnIndex] = !(headerText.includes('Nota') || headerText.includes('Pontuação Total') || headerText === 'Classificação' || headerText === 'Posição');
            }

            const sortedRows = rows.sort((a, b) => {
                const textA = a.cells[columnIndex].textContent.trim();
                const textB = b.cells[columnIndex].textContent.trim();

                const numA = parseFloat(textA.replace(',', '.'));
                const numB = parseFloat(textB.replace(',', '.'));

                if (!isNaN(numA) && !isNaN(numB)) {
                    return sortDirections[columnIndex] ? numA - numB : numB - numA;
                } else {
                    return sortDirections[columnIndex] ? textA.localeCompare(textB) : textB.localeCompare(textA);
                }
            });

            sortDirections[columnIndex] = !sortDirections[columnIndex];

            tbody.innerHTML = '';
            sortedRows.forEach(row => tbody.appendChild(row));
        }

        window.onload = function() {
            // A inicialização de sortDirections e a ordenação inicial são tratadas dentro de updateTable.
        };

        function searchTable() {
            let input = document.getElementById('searchInput').value.toUpperCase();
            let table = document.getElementById('resultTable');
            let tr = table.getElementsByTagName('tr');

            for (let i = 1; i < tr.length; i++) {
                let td = tr[i].getElementsByTagName('td');
                let found = false;
                for (let j = 0; j < td.length; j++) {
                    if (td[j] && td[j].innerHTML.toUpperCase().indexOf(input) > -1) {
                        found = true;
                        break;
                    }
                }
                tr[i].style.display = found ? '' : 'none';
            }
        }

        function generatePDF() {
            try {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();

                const margin = 10;
                let y = margin;
                const lineHeight = 10;
                const pageWidth = doc.internal.pageSize.getWidth();

                doc.setFontSize(16);
                doc.setFont("helvetica", "bold");
                const title = "Relatório de Resultados";
                const titleWidth = doc.getTextWidth(title);
                const x = (pageWidth - titleWidth) / 2;
                doc.text(title, x, y);
                y += lineHeight * 2;

                const table = document.getElementById('resultTable');
                if (!table || table.querySelector('tbody').children.length === 0) {
                    alert("Erro: Gere a tabela primeiro clicando em 'Organizar'!");
                    return;
                }

                const headers = Array.from(table.querySelectorAll('thead th')).map(th => th.textContent);
                const rows = Array.from(table.querySelectorAll('tbody tr')).map(tr =>
                    Array.from(tr.querySelectorAll('td')).map(td => 
                        td.textContent.replace(/\s*\n\s*/g, ' ').trim()
                    )
                );

                doc.autoTable({
                    head: [headers],
                    body: rows,
                    startY: y,
                    margin: { left: margin, right: margin },
                    styles: { fontSize: 10, cellPadding: 2 },
                    headStyles: { fillColor: [76, 175, 80], textColor: 255 },
                    alternateRowStyles: { fillColor: [224, 242, 241] },
                });

                const pdfBlob = doc.output('blob');
                const pdfUrl = URL.createObjectURL(pdfBlob);
                window.open(pdfUrl, '_blank');
            } catch (error) {
                console.error("Erro ao gerar PDF:", error);
                alert("Erro ao gerar PDF. Veja o console para detalhes.");
            }
        }
    </script>
</body>
</html>
